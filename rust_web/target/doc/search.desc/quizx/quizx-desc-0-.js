searchState.loadedDescShard("quizx", 0, "Basic ZX-calculus rules\nJson encoding for interoperability with pyzx and zxlang …\nMatrices and linear algebra over F2\nPhase encoded as either rational or floating point number …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA checked implementation of the rule\nCheck color_change_unchecked applies\nCheck gen_pivot applies\nCheck gen_pivot applies and at least one vertex is …\nCheck local_comp_unchecked applies\nCheck pi_copy_unchecked applies\nCheck pivot_unchecked applies\nCheck remove_id_unchecked applies\nCheck spider_fusion_unchecked applies\nA checked implementation of the rule\nChange the color of a Z or X spider\nA checked implementation of the rule\nA checked implementation of the rule\nGeneric version of the pivot rule\nA checked implementation of the rule\nApply a local complementation\nA checked implementation of the rule\nApply a pi-copy\nA checked implementation of the rule\nApply pivoting to a pair of vertices\nA checked implementation of the rule\nRemove an arity-2 spider with phase 0\nA checked implementation of the rule\nRemove an isolated Z or X vertex and add it as a global …\nA checked implementation of the rule\nRemove an isolated Z or X vertex and add it as a global …\nA checked implementation of the rule\nApply spider fusion\nA type for quantum circuits\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImplements (roughly) <code>basic_optimization</code> from pyzx\nreturns a copy of the circuit, decomposed into 1- and …\nStore the (partial) decomposition of a graph into …\nReturns a best occurrence of a cat state The fist vertex …\nDecompose until there are no T gates left\nDecompose in parallel, starting at the given depth\nDecompose the first &lt;= 6 T gates in the graph on the top …\nDecompose breadth-first until the given depth\nPick the first &lt;= 6 T gates from the given graph\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes <code>terms_for_tcount</code> for every graph on the stack\nMerge N decomposers into 1, adding scalars together\nPick &lt;= 6 T gates from the given graph, chosen at random\nSplit a Decomposer with N graphs on the stack into N …\nGives upper bound for number of terms needed for BSS …\nExtraction couldn’t finish. Returns a message, a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDon’t do gaussian elimination on frontier\nPerform gaussian elimination on the frontier as CNOT gates\nPerform row operations to free a single vertex with the …\nThis is the main representation of scalars used in QuiZX. …\nDefines a multiplicative identity element for <code>Self</code>.\nDefines an additive identity element for <code>Self</code>.\nConstructs a scalar as a complex number <code>re + im * i</code>.\nConverts <code>FScalar</code> into a <code>Complex&lt;f64&gt;</code>\nReturns the complex conjugate of the scalar\nConstructs a scalar from a power of two and 4 integer …\nReturns an array of 4 pairs giving each coefficient as a …\nIf the scalar is an exact representation of a number in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>self</code> is equal to the multiplicative …\nReturns <code>true</code> if <code>self</code> is equal to the additive identity.\nConvience method for multipling by <code>1 + e^(i π * phase)</code> …\nConvience method for multipling by <code>e^(i π * phase)</code> for …\nConvience method for multipling by the given power of …\nReturns the multiplicative identity element of <code>Self</code>, <code>1</code>.\nConstructs a scalar <code>1 + e^(i π * phase)</code> for the given …\nConstructs a scalar as a real number with the given float …\nSets <code>self</code> to the multiplicative identity element of <code>Self</code>, <code>1</code>…\nSets <code>self</code> to the additive identity element of <code>Self</code>, <code>0</code>.\nReturns the additive identity element of <code>Self</code>, <code>0</code>.\nadd the gate to the given graph using spiders\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nnumber of 1- and 2-qubit Clifford + phase gates needed to …\nnumber of qubits the gate acts on\ndecompose as 1 and 2 qubit Clifford + phase gates and push …\nConvenience method for generating Clifford+T circuits\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDistribute the remaining probability evenly among Clifford …\nAn enum specifying an X or Z basis element\nCoordinates for rendering a node.\nHadamard edge.\nNormal edge.\nThe type of a vertex in a graph.\nW input/output\nAdd an edge and simplify if necessary to remove parallel …\nAdd an edge with the given type\nAdd a vertex with the given name and VData struct\nAdds a value to the phase of a vertex\nAdd a vertex with the given type\nAdd a vertex with the given VData struct\nAdd a vertex to the graph with the given type and phase\nExchange inputs and outputs and reverse all phases\nAppends the given graph to the current one, with fresh …\nReturns vertices in the components of g\nReturns max row of any vertex\nGet iterator over all edges\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nList of boundary vertices which serve as inputs\nMutable list of boundary vertices which serve as inputs\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if the given graph only consists of wires from the …\nInitialise a new empty graph\nCreate a new coordinate.\nNumber of edges\nNumber of vertices\nList of boundary vertices which serve as outputs\nMutable list of boundary vertices which serve as outputs\nReturns the phase of vertex <code>v</code>\nPlug the given graph into the outputs and multiply scalars\nPlug the given basis vertex into the i-th input.\nPlug the given list of normalised basis elements in as …\nPlug the given basis vertex into the i-th output.\nPlug the given list of normalised basis elements in as …\nReplace a boundary vertex with the given basis element\nInfer the qubit index from the y-coordinate.\nRemove an edge from a graph\nRemove a vertex from a graph\nInfer the row index from the x-coordinate.\nSet inputs for the graph\nSet outputs for the graph\nSet the phase of a vertex\nReturns the full subgraph containing the given vertices\nReturn number of Z or X spiders with non-Clifford phase\nSame as GraphLike::adjoint(), but return as a copy\nReturn a graphviz-friendly string representation of the …\nGet iterator over all vertices\nNext fresh vertex index\nConvert all X spiders to Z with the colour-change rule\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFound an invalid phase value in a node definition.\nFound an invalid phase value.\nAn error that can occur when decoding a json graph.\nThe json-encoded format for pyzx and zxlang graphs.\nA phase, in half turns.\nGlobal scalars in a graph\nA set of options for encoding and decoding phases.\nSome other serde error.\nReads a graph from its json-encoded representation.\nReturns the json-encoded representation of a graph.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEncode a graph using the json representation.\nEncode a vertex phase.\nIf set to <code>true</code>, then encoded phases will not include the …\nIf set to <code>true</code>, then encoded phases will not include the …\nIgnore this value when encoding phases.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLimit the denominator of the phase to this value.\nReads a graph from a json-encoded file.\nDecode a graph from the json representation.\nDecode a vertex phase.\nReturns an scalar marked as “unknown”.\nWrites the json-encoded representation of a graph to a …\nA type for matrices over F2\nBuild a matrix with the given number of rows and columns. …\nAdd c0 to c1\nSwap c0 and c1\nReturns the argument unchanged.\nThe identity matrix of a given size\nCalls <code>U::from(self)</code>.\nA matrix full of ones\nAdd r0 to r1\nSwap r0 and r1\nReturn the hamming weight of the given row\nReturn the transpose as a copy\nReturn a list of rows which have a single 1\nA column vector with a single 1 at the given index\nReturn the hamming weight of the whole matrix\nA matrix full of zeros\nA phase, expressed in half-turns and encoded as a rational …\nReturns the argument unchanged.\nCreates a new phase from a floating point number of …\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the phase is a multiple of 1/2.\nReturns <code>true</code> if the phase is 0 or 1.\nReturns <code>true</code> if the phase is either -1/2 or 1/2.\nReturns <code>true</code> if the phase a non-clifford multiple of 1/4.\nApproximate a phase’s fraction to a Rational64 number …\nCreates a new phase.\nNormalizes the phase to be in the range (-1,1] by adding …\nReturns the phase as a floating point number of half-turns.\nReturns the phase as a rational number.\nUtility functions for phase values.\nApproximate a fraction to a Rational64 number with a small …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nProduce a number from rational root of -1.\nContains the numbers sqrt(2) and 1/sqrt(2), often used for …\nReturns a number from a rational phase.\nReturns the number -1.\nReturn the number 1/sqrt(2).\nReturn the number sqrt(2).\nReturn the p-th power of sqrt(2).\nRepeatedly apply the given rule at any vertex that matches …\nGeneric tensor type used by quizx\nShorthand for tensors over floating point complex numbers\nWraps all the traits we need to compute tensors from …\nShorthand for tensors over FScalar\nTrait that implements conversion of graphs to tensors\ncontract the last n qubit indices with the first n qubits …\nsplit into two non-overlapping pieces, where index q=0 and …\nShorthand for <code>to_tensor::&lt;Complex&lt;f64&gt;&gt;()</code>\nShorthand for <code>to_tensor::&lt;FScalar&gt;()</code>\nThe same as max(iterable), but the elements are allowed to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExplicitly index neighbors of a vertex. Used for iteration.")